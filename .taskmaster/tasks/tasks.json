{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup with Manifest V3",
        "description": "Initialize the Chrome extension project with Manifest V3 configuration and basic folder structure.",
        "details": "Create a new project directory and set up the following:\n1. Create manifest.json with Manifest V3 configuration\n2. Set up basic folder structure (src/, dist/, assets/)\n3. Initialize package.json with npm init\n4. Configure Vite or ESBuild for bundling\n5. Set up ESLint and Prettier for code quality\n6. Create .gitignore file\n\nManifest.json should include:\n```json\n{\n  \"manifest_version\": 3,\n  \"name\": \"RottenTomatoesReelScore\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Displays the difference between critic and audience scores on RottenTomatoes.com\",\n  \"icons\": {\n    \"16\": \"assets/icon16.png\",\n    \"48\": \"assets/icon48.png\",\n    \"128\": \"assets/icon128.png\"\n  },\n  \"action\": {\n    \"default_popup\": \"popup.html\",\n    \"default_icon\": \"assets/icon48.png\"\n  },\n  \"permissions\": [\"storage\"],\n  \"host_permissions\": [\"*://*.rottentomatoes.com/*\"],\n  \"content_scripts\": [{\n    \"matches\": [\"*://*.rottentomatoes.com/*\"],\n    \"js\": [\"content.js\"]\n  }],\n  \"options_page\": \"options.html\"\n}\n```\n<info added on 2025-07-03T20:05:35.243Z>\n# Implementation Plan (Phase 1):\n\n1. Directory & Git Setup\n   - Ensure root clean. Create folders: src/, assets/, dist/.\n   - Add placeholder icons (16,48,128 PNG).\n\n2. Manifest V3\n   - Create manifest.json in root with fields as specified in task details; point to compiled JS in dist/.\n\n3. NPM & Tooling\n   - `npm init -y` to create package.json.\n   - Add scripts: `dev` -> `vite`, `build` -> `vite build`.\n   - Install dev dependencies: vite, eslint, prettier, vite-plugin-crx-mv3 (optional).\n   - Configure vite.config.js to copy manifest & assets and bundle src/content.js into dist/content.js.\n\n4. Linting & Formatting\n   - Create .eslintrc.json with recommended settings for ES2022 browser.\n   - Create .prettierrc and .prettierignore.\n\n5. .gitignore\n   - node_modules, dist, .DS_Store, .env.\n\n6. Initial Source\n   - src/content.js: placeholder that logs 'ReelScore content script active'.\n   - src/options.js / options.html basic toggle checkbox (scaffold).\n   - popup.html w/ simple header.\n\n7. Verification\n   - Run `npm run dev` and load `dist` as unpacked extension in Chrome to verify manifest & content script.\n\nPhase 2 (future): integrate MutationObserver & score DOM extraction.\n</info added on 2025-07-03T20:05:35.243Z>",
        "testStrategy": "Verify project structure is correct. Run linting to ensure code style compliance. Test bundling process to ensure it produces valid output under 150KB.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Score Extraction Logic",
        "description": "Create functionality to extract Tomatometer and Popcorn Meter scores from the RottenTomatoes DOM.",
        "details": "Create a module that:\n1. Identifies and selects the DOM elements containing the Tomatometer and Popcorn Meter scores\n2. Extracts the percentage values from these elements\n3. Handles cases where one or both scores might not be available\n4. Returns the extracted scores as numbers\n\n```javascript\n// scoreExtractor.js\nexport function extractScores() {\n  // Robust selectors for Tomatometer and Popcorn Meter\n  // These selectors may need adjustment based on actual RT DOM structure\n  const tomatoMeterEl = document.querySelector('.tomatometer .percentage');\n  const popcornMeterEl = document.querySelector('.audience-score .percentage');\n  \n  // Extract and parse scores\n  const tomatoMeter = tomatoMeterEl ? parseInt(tomatoMeterEl.textContent, 10) : null;\n  const popcornMeter = popcornMeterEl ? parseInt(popcornMeterEl.textContent, 10) : null;\n  \n  return { tomatoMeter, popcornMeter };\n}\n```\n\nImplement a MutationObserver to detect when scores become available on the page, as RT is an SPA:\n\n```javascript\nexport function observeScoreElements(callback) {\n  const observer = new MutationObserver((mutations) => {\n    // Check if score elements are now in the DOM\n    const { tomatoMeter, popcornMeter } = extractScores();\n    if (tomatoMeter !== null && popcornMeter !== null) {\n      callback({ tomatoMeter, popcornMeter });\n    }\n  });\n  \n  // Observe the entire document for changes\n  observer.observe(document.body, { childList: true, subtree: true });\n  return observer;\n}\n```",
        "testStrategy": "Create Jest tests with jsdom to verify score extraction from sample RottenTomatoes HTML. Test with various score values and edge cases (missing scores, non-numeric values). Measure performance to ensure extraction completes within performance budget.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Reel Score Calculation",
        "description": "Create a function to calculate the Reel Score as the difference between Popcorn Meter and Tomatometer.",
        "details": "Create a module that:\n1. Takes the extracted Tomatometer and Popcorn Meter scores as input\n2. Calculates the difference (Popcorn Meter - Tomatometer)\n3. Returns the calculated Reel Score\n\n```javascript\n// reelScoreCalculator.js\nexport function calculateReelScore(popcornMeter, tomatoMeter) {\n  // Handle cases where one or both scores might be missing\n  if (popcornMeter === null || tomatoMeter === null) {\n    return null;\n  }\n  \n  // Calculate the difference\n  return popcornMeter - tomatoMeter;\n}\n\n// Determine the visual representation based on the score\nexport function getReelScoreVisuals(reelScore) {\n  if (reelScore === null) {\n    return { color: '#95a5a6', icon: 'neutral', description: 'Score unavailable' };\n  }\n  \n  if (reelScore > 0) {\n    return {\n      color: '#2ecc71', // Green\n      icon: 'thumbs-up',\n      description: `Audience score is ${Math.abs(reelScore)}% higher than critics.`\n    };\n  } else if (reelScore < 0) {\n    return {\n      color: '#e74c3c', // Red\n      icon: 'thumbs-down',\n      description: `Audience score is ${Math.abs(reelScore)}% lower than critics.`\n    };\n  } else {\n    return {\n      color: '#95a5a6', // Gray\n      icon: 'neutral',\n      description: 'Critics and audiences agree exactly.'\n    };\n  }\n}\n```",
        "testStrategy": "Write Jest tests to verify calculation logic with various input combinations. Test edge cases like extreme differences, zero difference, and missing scores. Verify the visual representation logic returns the correct colors and icons based on the score.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Design and Create Badge UI Elements",
        "description": "Create the visual badge elements that will display the Reel Score on the page.",
        "details": "Create a module that generates the badge HTML and CSS:\n\n```javascript\n// badgeCreator.js\nexport function createBadgeElement(reelScore, visuals) {\n  // Create the badge container\n  const badge = document.createElement('div');\n  badge.className = 'reel-score-badge';\n  badge.style.cssText = `\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    width: 36px;\n    height: 36px;\n    border-radius: 50%;\n    background-color: ${visuals.color};\n    color: white;\n    font-weight: bold;\n    margin-left: 8px;\n    position: relative;\n    cursor: help;\n  `;\n  \n  // Add the score text\n  const scoreText = document.createElement('span');\n  scoreText.textContent = Math.abs(reelScore);\n  badge.appendChild(scoreText);\n  \n  // Add the icon\n  const icon = document.createElement('div');\n  icon.className = 'reel-score-icon';\n  icon.style.cssText = `\n    position: absolute;\n    bottom: -2px;\n    right: -2px;\n    font-size: 12px;\n  `;\n  \n  // Set the icon based on the score\n  if (visuals.icon === 'thumbs-up') {\n    icon.innerHTML = '👍';\n  } else if (visuals.icon === 'thumbs-down') {\n    icon.innerHTML = '👎';\n  } else {\n    icon.innerHTML = '✋';\n  }\n  \n  badge.appendChild(icon);\n  \n  // Add accessibility attributes\n  badge.setAttribute('aria-label', visuals.description);\n  \n  // Add tooltip functionality\n  badge.setAttribute('title', visuals.description);\n  \n  return badge;\n}\n\n// Inject the badge styles into the page\nexport function injectBadgeStyles() {\n  const style = document.createElement('style');\n  style.textContent = `\n    .reel-score-badge {\n      font-family: ShockSans, Arial, sans-serif;\n      transition: opacity 0.2s ease;\n    }\n    \n    .reel-score-badge:hover {\n      opacity: 0.9;\n    }\n  `;\n  document.head.appendChild(style);\n}\n```",
        "testStrategy": "Create visual tests to verify badge appearance matches design specifications. Test with different score values to ensure correct color coding and icon selection. Verify accessibility attributes are correctly set. Test on different screen sizes to ensure responsive behavior.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Badge Injection Logic",
        "description": "Create functionality to inject the Reel Score badge into the RottenTomatoes page next to the existing score elements.",
        "details": "Create a module that:\n1. Identifies the appropriate locations to inject the badges\n2. Injects the badges next to the Tomatometer and Popcorn Meter\n3. Ensures badges are properly positioned in the layout\n\n```javascript\n// badgeInjector.js\nimport { extractScores } from './scoreExtractor.js';\nimport { calculateReelScore, getReelScoreVisuals } from './reelScoreCalculator.js';\nimport { createBadgeElement, injectBadgeStyles } from './badgeCreator.js';\n\n// Inject badges next to score elements\nexport function injectBadges() {\n  // Extract scores\n  const { tomatoMeter, popcornMeter } = extractScores();\n  \n  // Calculate Reel Score\n  const reelScore = calculateReelScore(popcornMeter, tomatoMeter);\n  if (reelScore === null) return;\n  \n  // Get visual representation\n  const visuals = getReelScoreVisuals(reelScore);\n  \n  // Create badge element\n  const badge = createBadgeElement(reelScore, visuals);\n  \n  // Find injection points\n  const tomatoMeterContainer = document.querySelector('.tomatometer');\n  const popcornMeterContainer = document.querySelector('.audience-score');\n  \n  // Inject badges if containers exist\n  if (tomatoMeterContainer && !tomatoMeterContainer.querySelector('.reel-score-badge')) {\n    tomatoMeterContainer.appendChild(badge.cloneNode(true));\n  }\n  \n  if (popcornMeterContainer && !popcornMeterContainer.querySelector('.reel-score-badge')) {\n    popcornMeterContainer.appendChild(badge.cloneNode(true));\n  }\n}\n\n// Initialize badge injection with MutationObserver\nexport function initBadgeInjection() {\n  // Inject styles once\n  injectBadgeStyles();\n  \n  // Try immediate injection\n  injectBadges();\n  \n  // Set up observer for dynamic content\n  const observer = new MutationObserver(debounce(() => {\n    injectBadges();\n  }, 100));\n  \n  observer.observe(document.body, { childList: true, subtree: true });\n  return observer;\n}\n\n// Debounce helper function\nfunction debounce(func, wait) {\n  let timeout;\n  return function() {\n    const context = this;\n    const args = arguments;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(context, args), wait);\n  };\n}\n```",
        "testStrategy": "Create tests with jsdom to verify badge injection at correct locations. Test with dynamic page changes to ensure MutationObserver correctly detects and responds to DOM updates. Measure performance to ensure badges are injected within 200ms of scores being visible. Test on various RottenTomatoes page layouts.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Content Script Main Logic",
        "description": "Create the main content script that initializes and coordinates all functionality when the extension runs on RottenTomatoes pages.",
        "details": "Create the main content script that ties everything together:\n\n```javascript\n// content.js\nimport { initBadgeInjection } from './badgeInjector.js';\n\n// Check if we're on a RottenTomatoes movie or TV show page\nfunction isRelevantPage() {\n  const url = window.location.href;\n  return url.includes('rottentomatoes.com') && \n         (url.includes('/m/') || url.includes('/tv/'));\n}\n\n// Initialize the extension\nasync function initialize() {\n  // Check if we're on a relevant page\n  if (!isRelevantPage()) return;\n  \n  // Check if extension is enabled in storage\n  const { enabled = true } = await chrome.storage.sync.get('enabled');\n  if (!enabled) return;\n  \n  // Initialize badge injection\n  const observer = initBadgeInjection();\n  \n  // Listen for storage changes (e.g., if user disables extension)\n  chrome.storage.onChanged.addListener((changes) => {\n    if (changes.enabled) {\n      if (!changes.enabled.newValue) {\n        // Extension disabled, remove badges and disconnect observer\n        document.querySelectorAll('.reel-score-badge').forEach(badge => badge.remove());\n        observer.disconnect();\n      } else if (changes.enabled.newValue && !changes.enabled.oldValue) {\n        // Extension re-enabled, restart\n        initialize();\n      }\n    }\n  });\n}\n\n// Start the extension\ninitialize();\n```",
        "testStrategy": "Test the initialization logic with different URL patterns to verify it only activates on relevant pages. Test the storage listener to ensure it correctly responds to enable/disable changes. Measure overall performance to ensure the extension initializes and renders badges within performance targets.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create Options Page",
        "description": "Implement a simple options page that allows users to enable/disable the extension.",
        "details": "Create the options page HTML and JavaScript:\n\n```html\n<!-- options.html -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>RottenTomatoesReelScore Options</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      padding: 20px;\n      max-width: 600px;\n      margin: 0 auto;\n    }\n    .option-row {\n      margin-bottom: 20px;\n      display: flex;\n      align-items: center;\n    }\n    .switch {\n      position: relative;\n      display: inline-block;\n      width: 60px;\n      height: 34px;\n      margin-right: 15px;\n    }\n    .switch input {\n      opacity: 0;\n      width: 0;\n      height: 0;\n    }\n    .slider {\n      position: absolute;\n      cursor: pointer;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      background-color: #ccc;\n      transition: .4s;\n      border-radius: 34px;\n    }\n    .slider:before {\n      position: absolute;\n      content: \"\";\n      height: 26px;\n      width: 26px;\n      left: 4px;\n      bottom: 4px;\n      background-color: white;\n      transition: .4s;\n      border-radius: 50%;\n    }\n    input:checked + .slider {\n      background-color: #2ecc71;\n    }\n    input:checked + .slider:before {\n      transform: translateX(26px);\n    }\n  </style>\n</head>\n<body>\n  <h1>RottenTomatoesReelScore Options</h1>\n  \n  <div class=\"option-row\">\n    <label class=\"switch\">\n      <input type=\"checkbox\" id=\"enabled\">\n      <span class=\"slider\"></span>\n    </label>\n    <span>Enable Reel Score badges</span>\n  </div>\n  \n  <div id=\"status\"></div>\n  \n  <script src=\"options.js\"></script>\n</body>\n</html>\n```\n\n```javascript\n// options.js\ndocument.addEventListener('DOMContentLoaded', async () => {\n  // Load saved settings\n  const { enabled = true } = await chrome.storage.sync.get('enabled');\n  document.getElementById('enabled').checked = enabled;\n  \n  // Save settings when changed\n  document.getElementById('enabled').addEventListener('change', (event) => {\n    chrome.storage.sync.set({ enabled: event.target.checked });\n    \n    // Show saved message\n    const status = document.getElementById('status');\n    status.textContent = 'Options saved.';\n    setTimeout(() => {\n      status.textContent = '';\n    }, 1500);\n  });\n});\n```",
        "testStrategy": "Test the options page UI to ensure toggle works correctly. Verify that changes to the enabled state are correctly saved to Chrome storage. Test that the content script correctly responds to changes in the enabled state.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Tooltip Functionality",
        "description": "Enhance the badge with a tooltip that explains the Reel Score difference when users hover over it.",
        "details": "Enhance the badge creation function to include tooltip functionality:\n\n```javascript\n// Update the createBadgeElement function in badgeCreator.js\nexport function createBadgeElement(reelScore, visuals) {\n  // ... existing badge creation code ...\n  \n  // Add tooltip functionality\n  // Option 1: Use native title attribute (simple approach)\n  badge.setAttribute('title', visuals.description);\n  \n  // Option 2: Custom tooltip for more styling control\n  const tooltip = document.createElement('div');\n  tooltip.className = 'reel-score-tooltip';\n  tooltip.textContent = visuals.description;\n  tooltip.style.cssText = `\n    position: absolute;\n    bottom: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n    background-color: #333;\n    color: white;\n    padding: 8px 12px;\n    border-radius: 4px;\n    font-size: 14px;\n    white-space: nowrap;\n    pointer-events: none;\n    opacity: 0;\n    transition: opacity 0.2s;\n    z-index: 1000;\n  `;\n  \n  badge.appendChild(tooltip);\n  \n  // Show/hide tooltip on hover\n  badge.addEventListener('mouseenter', () => {\n    tooltip.style.opacity = '1';\n  });\n  \n  badge.addEventListener('mouseleave', () => {\n    tooltip.style.opacity = '0';\n  });\n  \n  return badge;\n}\n\n// Update the injectBadgeStyles function\nexport function injectBadgeStyles() {\n  const style = document.createElement('style');\n  style.textContent = `\n    .reel-score-badge {\n      font-family: ShockSans, Arial, sans-serif;\n      transition: opacity 0.2s ease;\n      position: relative;\n    }\n    \n    .reel-score-badge:hover {\n      opacity: 0.9;\n    }\n    \n    /* Add a small arrow to the tooltip */\n    .reel-score-tooltip::after {\n      content: '';\n      position: absolute;\n      top: 100%;\n      left: 50%;\n      margin-left: -5px;\n      border-width: 5px;\n      border-style: solid;\n      border-color: #333 transparent transparent transparent;\n    }\n  `;\n  document.head.appendChild(style);\n}\n```",
        "testStrategy": "Test tooltip visibility on hover events. Verify tooltip text correctly reflects the score difference. Test tooltip positioning across different screen sizes and browser configurations. Verify tooltip doesn't interfere with other page elements.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement i18n Support",
        "description": "Set up internationalization support for the extension, starting with English.",
        "details": "Set up i18n support using Chrome's i18n API:\n\n1. Create a `_locales` folder in the project root\n2. Create language subfolders (e.g., `_locales/en`)\n3. Create message files for each language\n\n```json\n// _locales/en/messages.json\n{\n  \"appName\": {\n    \"message\": \"RottenTomatoesReelScore\",\n    \"description\": \"The name of the extension\"\n  },\n  \"appDescription\": {\n    \"message\": \"Displays the difference between critic and audience scores on RottenTomatoes.com\",\n    \"description\": \"The description of the extension\"\n  },\n  \"audienceHigher\": {\n    \"message\": \"Audience score is $DIFFERENCE$% higher than critics.\",\n    \"description\": \"Tooltip for positive Reel Score\",\n    \"placeholders\": {\n      \"difference\": {\n        \"content\": \"$1\",\n        \"example\": \"15\"\n      }\n    }\n  },\n  \"audienceLower\": {\n    \"message\": \"Audience score is $DIFFERENCE$% lower than critics.\",\n    \"description\": \"Tooltip for negative Reel Score\",\n    \"placeholders\": {\n      \"difference\": {\n        \"content\": \"$1\",\n        \"example\": \"15\"\n      }\n    }\n  },\n  \"scoresEqual\": {\n    \"message\": \"Critics and audiences agree exactly.\",\n    \"description\": \"Tooltip for zero Reel Score\"\n  },\n  \"scoreUnavailable\": {\n    \"message\": \"Score unavailable\",\n    \"description\": \"Tooltip when score cannot be calculated\"\n  },\n  \"enableExtension\": {\n    \"message\": \"Enable Reel Score badges\",\n    \"description\": \"Options page toggle label\"\n  },\n  \"optionsSaved\": {\n    \"message\": \"Options saved.\",\n    \"description\": \"Confirmation message on options page\"\n  }\n}\n```\n\nUpdate the manifest.json to include i18n support:\n\n```json\n{\n  \"manifest_version\": 3,\n  \"name\": \"__MSG_appName__\",\n  \"description\": \"__MSG_appDescription__\",\n  \"default_locale\": \"en\",\n  // ... rest of manifest ...\n}\n```\n\nUpdate the relevant code to use i18n messages:\n\n```javascript\n// In reelScoreCalculator.js\nexport function getReelScoreVisuals(reelScore) {\n  if (reelScore === null) {\n    return {\n      color: '#95a5a6',\n      icon: 'neutral',\n      description: chrome.i18n.getMessage('scoreUnavailable')\n    };\n  }\n  \n  if (reelScore > 0) {\n    return {\n      color: '#2ecc71',\n      icon: 'thumbs-up',\n      description: chrome.i18n.getMessage('audienceHigher', [Math.abs(reelScore)])\n    };\n  } else if (reelScore < 0) {\n    return {\n      color: '#e74c3c',\n      icon: 'thumbs-down',\n      description: chrome.i18n.getMessage('audienceLower', [Math.abs(reelScore)])\n    };\n  } else {\n    return {\n      color: '#95a5a6',\n      icon: 'neutral',\n      description: chrome.i18n.getMessage('scoresEqual')\n    };\n  }\n}\n```\n\nSimilarly update options.html and options.js to use i18n messages.",
        "testStrategy": "Verify that all user-facing strings are externalized to message files. Test that messages are correctly displayed in the UI. Test with different locale settings to ensure the extension falls back to English when needed.",
        "priority": "low",
        "dependencies": [
          6,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Performance Optimization",
        "description": "Optimize the extension to ensure it meets performance targets, particularly the 200ms render time.",
        "details": "Implement performance optimizations:\n\n1. Optimize DOM queries:\n```javascript\n// Cache DOM queries where possible\nlet tomatoMeterEl = null;\nlet popcornMeterEl = null;\n\nexport function extractScores() {\n  // Only query the DOM if elements aren't cached\n  if (!tomatoMeterEl) {\n    tomatoMeterEl = document.querySelector('.tomatometer .percentage');\n  }\n  if (!popcornMeterEl) {\n    popcornMeterEl = document.querySelector('.audience-score .percentage');\n  }\n  \n  // Reset cache if elements are no longer in the DOM\n  if (tomatoMeterEl && !document.contains(tomatoMeterEl)) {\n    tomatoMeterEl = null;\n  }\n  if (popcornMeterEl && !document.contains(popcornMeterEl)) {\n    popcornMeterEl = null;\n  }\n  \n  // Extract and parse scores\n  const tomatoMeter = tomatoMeterEl ? parseInt(tomatoMeterEl.textContent, 10) : null;\n  const popcornMeter = popcornMeterEl ? parseInt(popcornMeterEl.textContent, 10) : null;\n  \n  return { tomatoMeter, popcornMeter };\n}\n```\n\n2. Optimize MutationObserver:\n```javascript\n// Use a more targeted MutationObserver\nexport function observeScoreElements(callback) {\n  // Try to find a container that will include both score elements\n  const scoreContainer = document.querySelector('.scores-container') || document.body;\n  \n  const observer = new MutationObserver(debounce((mutations) => {\n    // Check if score elements are now in the DOM\n    const { tomatoMeter, popcornMeter } = extractScores();\n    if (tomatoMeter !== null && popcornMeter !== null) {\n      callback({ tomatoMeter, popcornMeter });\n    }\n  }, 50)); // Shorter debounce time for faster response\n  \n  // Observe the score container for changes\n  observer.observe(scoreContainer, { childList: true, subtree: true });\n  return observer;\n}\n```\n\n3. Optimize badge creation:\n```javascript\n// Pre-create badge templates to clone instead of creating from scratch each time\nlet badgeTemplates = {};\n\nexport function createBadgeElement(reelScore, visuals) {\n  const key = `${visuals.color}-${Math.abs(reelScore)}`;\n  \n  // Use cached template if available\n  if (badgeTemplates[key]) {\n    return badgeTemplates[key].cloneNode(true);\n  }\n  \n  // Create new badge\n  const badge = document.createElement('div');\n  // ... existing badge creation code ...\n  \n  // Cache the template\n  badgeTemplates[key] = badge;\n  \n  return badge.cloneNode(true);\n}\n```\n\n4. Add performance measurement:\n```javascript\n// Add to content.js\nfunction measurePerformance() {\n  const start = performance.now();\n  \n  // Create a MutationObserver to detect when scores appear\n  const observer = new MutationObserver(() => {\n    const { tomatoMeter, popcornMeter } = extractScores();\n    if (tomatoMeter !== null && popcornMeter !== null) {\n      // Start timing when scores are detected\n      const scoresDetectedTime = performance.now();\n      \n      // Set up another observer to detect when our badge appears\n      const badgeObserver = new MutationObserver(() => {\n        if (document.querySelector('.reel-score-badge')) {\n          const badgeRenderedTime = performance.now();\n          const renderTime = badgeRenderedTime - scoresDetectedTime;\n          \n          console.log(`Reel Score render time: ${renderTime.toFixed(2)}ms`);\n          \n          // Report if over budget\n          if (renderTime > 200) {\n            console.warn(`Render time exceeds 200ms budget: ${renderTime.toFixed(2)}ms`);\n          }\n          \n          badgeObserver.disconnect();\n        }\n      });\n      \n      badgeObserver.observe(document.body, { childList: true, subtree: true });\n      observer.disconnect();\n    }\n  });\n  \n  observer.observe(document.body, { childList: true, subtree: true });\n}\n\n// Call this in development/testing builds\nif (process.env.NODE_ENV === 'development') {\n  measurePerformance();\n}\n```",
        "testStrategy": "Measure render time using the Performance API to verify it's under 200ms. Test with various network conditions and page load scenarios. Verify that optimizations don't affect functionality. Measure memory usage to ensure there are no memory leaks from caching.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Error Handling and Logging",
        "description": "Add robust error handling and logging to track and diagnose issues in production.",
        "details": "Implement error handling and logging:\n\n```javascript\n// logger.js\nexport const LogLevel = {\n  ERROR: 'error',\n  WARN: 'warn',\n  INFO: 'info',\n  DEBUG: 'debug'\n};\n\nexport class Logger {\n  constructor(context = 'ReelScore') {\n    this.context = context;\n    this.enabled = true;\n    this.errorCount = 0;\n  }\n  \n  log(level, message, data = {}) {\n    if (!this.enabled) return;\n    \n    const logData = {\n      context: this.context,\n      timestamp: new Date().toISOString(),\n      url: window.location.href,\n      ...data\n    };\n    \n    switch (level) {\n      case LogLevel.ERROR:\n        console.error(`[${this.context}] ${message}`, logData);\n        this.errorCount++;\n        // Could send to error reporting service here\n        break;\n      case LogLevel.WARN:\n        console.warn(`[${this.context}] ${message}`, logData);\n        break;\n      case LogLevel.INFO:\n        console.info(`[${this.context}] ${message}`, logData);\n        break;\n      case LogLevel.DEBUG:\n        console.debug(`[${this.context}] ${message}`, logData);\n        break;\n    }\n  }\n  \n  error(message, data = {}) {\n    this.log(LogLevel.ERROR, message, data);\n  }\n  \n  warn(message, data = {}) {\n    this.log(LogLevel.WARN, message, data);\n  }\n  \n  info(message, data = {}) {\n    this.log(LogLevel.INFO, message, data);\n  }\n  \n  debug(message, data = {}) {\n    this.log(LogLevel.DEBUG, message, data);\n  }\n  \n  getErrorCount() {\n    return this.errorCount;\n  }\n}\n\n// Create a global logger instance\nexport const logger = new Logger();\n\n// Add global error handler\nexport function setupGlobalErrorHandling() {\n  window.addEventListener('error', (event) => {\n    logger.error('Uncaught error', {\n      message: event.message,\n      filename: event.filename,\n      lineno: event.lineno,\n      colno: event.colno,\n      stack: event.error?.stack\n    });\n  });\n  \n  window.addEventListener('unhandledrejection', (event) => {\n    logger.error('Unhandled promise rejection', {\n      reason: event.reason?.message || event.reason,\n      stack: event.reason?.stack\n    });\n  });\n}\n```\n\nUpdate the content script to use the logger:\n\n```javascript\n// content.js\nimport { logger, setupGlobalErrorHandling } from './logger.js';\nimport { initBadgeInjection } from './badgeInjector.js';\n\n// Initialize the extension\nasync function initialize() {\n  try {\n    setupGlobalErrorHandling();\n    logger.info('Extension initializing');\n    \n    // Check if we're on a relevant page\n    if (!isRelevantPage()) {\n      logger.debug('Not a relevant page, exiting');\n      return;\n    }\n    \n    // Check if extension is enabled in storage\n    const { enabled = true } = await chrome.storage.sync.get('enabled');\n    if (!enabled) {\n      logger.debug('Extension disabled in settings, exiting');\n      return;\n    }\n    \n    // Initialize badge injection\n    logger.info('Initializing badge injection');\n    const observer = initBadgeInjection();\n    \n    // Listen for storage changes\n    chrome.storage.onChanged.addListener((changes) => {\n      if (changes.enabled) {\n        logger.info('Enabled setting changed', { newValue: changes.enabled.newValue });\n        // ... existing code ...\n      }\n    });\n    \n    logger.info('Extension initialized successfully');\n  } catch (error) {\n    logger.error('Failed to initialize extension', { error });\n  }\n}\n\n// Start the extension\ninitialize();\n```\n\nWrap other critical functions with try/catch blocks and add appropriate logging.",
        "testStrategy": "Test error handling by deliberately introducing errors and verifying they're caught and logged. Verify that the extension gracefully handles and recovers from errors. Test that the error count is accurately tracked.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Create Extension Icons and Assets",
        "description": "Design and create the extension icons and other visual assets.",
        "details": "Create the following assets:\n\n1. Extension icons in multiple sizes (16x16, 48x48, 128x128)\n2. Badge icons (thumbs up, thumbs down, neutral hand)\n\nIcon design guidelines:\n- Use a simple, recognizable design that represents the concept of comparing scores\n- Use colors that match the extension's visual language (green, red, gray)\n- Ensure icons are legible at small sizes\n- Create both regular and disabled states for the browser action icon\n\nSave the icons in the assets/ directory with appropriate names:\n- icon16.png (16x16)\n- icon48.png (48x48)\n- icon128.png (128x128)\n- icon16-disabled.png (16x16 grayscale version)\n- icon48-disabled.png (48x48 grayscale version)\n- icon128-disabled.png (128x128 grayscale version)\n\nUpdate the manifest.json to reference these icons:\n\n```json\n{\n  \"manifest_version\": 3,\n  \"name\": \"RottenTomatoesReelScore\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Displays the difference between critic and audience scores on RottenTomatoes.com\",\n  \"icons\": {\n    \"16\": \"assets/icon16.png\",\n    \"48\": \"assets/icon48.png\",\n    \"128\": \"assets/icon128.png\"\n  },\n  \"action\": {\n    \"default_popup\": \"popup.html\",\n    \"default_icon\": {\n      \"16\": \"assets/icon16.png\",\n      \"48\": \"assets/icon48.png\",\n      \"128\": \"assets/icon128.png\"\n    }\n  },\n  // ... rest of manifest ...\n}\n```\n\nImplement icon state changes based on extension enabled/disabled state:\n\n```javascript\n// Update icon based on enabled state\nfunction updateIcon(enabled) {\n  const iconPath = enabled ? {\n    16: 'assets/icon16.png',\n    48: 'assets/icon48.png',\n    128: 'assets/icon128.png'\n  } : {\n    16: 'assets/icon16-disabled.png',\n    48: 'assets/icon48-disabled.png',\n    128: 'assets/icon128-disabled.png'\n  };\n  \n  chrome.action.setIcon({ path: iconPath });\n}\n\n// Call this when extension state changes\nchrome.storage.onChanged.addListener((changes) => {\n  if (changes.enabled) {\n    updateIcon(changes.enabled.newValue);\n  }\n});\n\n// Initialize icon state\nchrome.storage.sync.get('enabled', ({ enabled = true }) => {\n  updateIcon(enabled);\n});\n```",
        "testStrategy": "Verify icons display correctly at all sizes. Test icon state changes when extension is enabled/disabled. Ensure icons are visible against different browser themes and backgrounds.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Create Simple Popup UI",
        "description": "Create a simple popup UI that appears when users click the extension icon in the toolbar.",
        "details": "Create the popup HTML and JavaScript:\n\n```html\n<!-- popup.html -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>RottenTomatoesReelScore</title>\n  <style>\n    body {\n      width: 300px;\n      padding: 15px;\n      font-family: Arial, sans-serif;\n    }\n    h1 {\n      font-size: 18px;\n      margin-top: 0;\n      color: #333;\n    }\n    .toggle-container {\n      display: flex;\n      align-items: center;\n      margin: 15px 0;\n    }\n    .switch {\n      position: relative;\n      display: inline-block;\n      width: 50px;\n      height: 24px;\n      margin-right: 10px;\n    }\n    .switch input {\n      opacity: 0;\n      width: 0;\n      height: 0;\n    }\n    .slider {\n      position: absolute;\n      cursor: pointer;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      background-color: #ccc;\n      transition: .4s;\n      border-radius: 24px;\n    }\n    .slider:before {\n      position: absolute;\n      content: \"\";\n      height: 16px;\n      width: 16px;\n      left: 4px;\n      bottom: 4px;\n      background-color: white;\n      transition: .4s;\n      border-radius: 50%;\n    }\n    input:checked + .slider {\n      background-color: #2ecc71;\n    }\n    input:checked + .slider:before {\n      transform: translateX(26px);\n    }\n    .footer {\n      margin-top: 15px;\n      font-size: 12px;\n      color: #666;\n      text-align: center;\n    }\n    .options-link {\n      display: block;\n      margin-top: 10px;\n      text-align: center;\n      font-size: 14px;\n      color: #3498db;\n      text-decoration: none;\n    }\n    .options-link:hover {\n      text-decoration: underline;\n    }\n  </style>\n</head>\n<body>\n  <h1>RottenTomatoesReelScore</h1>\n  \n  <p>See the difference between critic and audience scores on Rotten Tomatoes.</p>\n  \n  <div class=\"toggle-container\">\n    <label class=\"switch\">\n      <input type=\"checkbox\" id=\"enabled\">\n      <span class=\"slider\"></span>\n    </label>\n    <span>Enable Reel Score</span>\n  </div>\n  \n  <a href=\"#\" id=\"options-link\" class=\"options-link\">Advanced Options</a>\n  \n  <div class=\"footer\">\n    <p>v1.0.0</p>\n  </div>\n  \n  <script src=\"popup.js\"></script>\n</body>\n</html>\n```\n\n```javascript\n// popup.js\ndocument.addEventListener('DOMContentLoaded', async () => {\n  // Load saved settings\n  const { enabled = true } = await chrome.storage.sync.get('enabled');\n  document.getElementById('enabled').checked = enabled;\n  \n  // Save settings when changed\n  document.getElementById('enabled').addEventListener('change', (event) => {\n    chrome.storage.sync.set({ enabled: event.target.checked });\n  });\n  \n  // Open options page when link is clicked\n  document.getElementById('options-link').addEventListener('click', (event) => {\n    event.preventDefault();\n    chrome.runtime.openOptionsPage();\n  });\n});\n```",
        "testStrategy": "Test the popup UI to ensure it displays correctly. Verify that the enabled toggle correctly updates the storage value. Test that the options link correctly opens the options page.",
        "priority": "low",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Set Up Testing Framework",
        "description": "Set up Jest and jsdom for unit testing, and configure the testing environment.",
        "details": "Set up the testing framework:\n\n1. Install testing dependencies:\n```bash\nnpm install --save-dev jest jest-environment-jsdom @testing-library/dom @testing-library/jest-dom\n```\n\n2. Create Jest configuration:\n```javascript\n// jest.config.js\nmodule.exports = {\n  testEnvironment: 'jsdom',\n  setupFilesAfterEnv: ['./jest.setup.js'],\n  transform: {\n    '^.+\\.js$': 'babel-jest'\n  },\n  moduleNameMapper: {\n    '^@/(.*)$': '<rootDir>/src/$1'\n  },\n  collectCoverage: true,\n  collectCoverageFrom: [\n    'src/**/*.js',\n    '!src/**/*.test.js',\n    '!**/node_modules/**'\n  ],\n  coverageThreshold: {\n    global: {\n      statements: 70,\n      branches: 70,\n      functions: 70,\n      lines: 70\n    }\n  }\n};\n```\n\n3. Create Jest setup file:\n```javascript\n// jest.setup.js\nimport '@testing-library/jest-dom';\n\n// Mock Chrome API\nglobal.chrome = {\n  storage: {\n    sync: {\n      get: jest.fn(),\n      set: jest.fn()\n    },\n    onChanged: {\n      addListener: jest.fn()\n    }\n  },\n  runtime: {\n    openOptionsPage: jest.fn()\n  },\n  i18n: {\n    getMessage: jest.fn((key, placeholders) => {\n      // Simple mock implementation\n      if (key === 'audienceHigher' && placeholders) {\n        return `Audience score is ${placeholders[0]}% higher than critics.`;\n      }\n      if (key === 'audienceLower' && placeholders) {\n        return `Audience score is ${placeholders[0]}% lower than critics.`;\n      }\n      return key;\n    })\n  }\n};\n```\n\n4. Create sample test for score calculation:\n```javascript\n// src/reelScoreCalculator.test.js\nimport { calculateReelScore, getReelScoreVisuals } from './reelScoreCalculator';\n\ndescribe('calculateReelScore', () => {\n  test('calculates positive difference correctly', () => {\n    expect(calculateReelScore(90, 70)).toBe(20);\n  });\n  \n  test('calculates negative difference correctly', () => {\n    expect(calculateReelScore(70, 90)).toBe(-20);\n  });\n  \n  test('calculates zero difference correctly', () => {\n    expect(calculateReelScore(80, 80)).toBe(0);\n  });\n  \n  test('returns null when popcornMeter is null', () => {\n    expect(calculateReelScore(null, 70)).toBeNull();\n  });\n  \n  test('returns null when tomatoMeter is null', () => {\n    expect(calculateReelScore(70, null)).toBeNull();\n  });\n});\n\ndescribe('getReelScoreVisuals', () => {\n  test('returns green with thumbs-up for positive score', () => {\n    const visuals = getReelScoreVisuals(20);\n    expect(visuals.color).toBe('#2ecc71');\n    expect(visuals.icon).toBe('thumbs-up');\n    expect(visuals.description).toContain('20% higher');\n  });\n  \n  test('returns red with thumbs-down for negative score', () => {\n    const visuals = getReelScoreVisuals(-20);\n    expect(visuals.color).toBe('#e74c3c');\n    expect(visuals.icon).toBe('thumbs-down');\n    expect(visuals.description).toContain('20% lower');\n  });\n  \n  test('returns gray with neutral icon for zero score', () => {\n    const visuals = getReelScoreVisuals(0);\n    expect(visuals.color).toBe('#95a5a6');\n    expect(visuals.icon).toBe('neutral');\n    expect(visuals.description).toContain('agree exactly');\n  });\n});\n```\n\n5. Add test scripts to package.json:\n```json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\"\n  }\n}\n```",
        "testStrategy": "Run the test suite to verify it's correctly set up. Verify that Chrome API mocks work as expected. Test coverage reports to ensure they're generated correctly.",
        "priority": "medium",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Set Up CI/CD Pipeline",
        "description": "Configure GitHub Actions for continuous integration and deployment.",
        "details": "Set up GitHub Actions workflow:\n\n1. Create GitHub Actions workflow file:\n```yaml\n# .github/workflows/ci.yml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  release:\n    types: [ created ]\n\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Lint code\n        run: npm run lint\n      \n      - name: Run tests\n        run: npm test\n      \n      - name: Build extension\n        run: npm run build\n      \n      - name: Upload build artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: extension-build\n          path: dist/\n  \n  package:\n    needs: build-and-test\n    if: github.event_name == 'release'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Download build artifacts\n        uses: actions/download-artifact@v3\n        with:\n          name: extension-build\n          path: dist/\n      \n      - name: Package extension\n        run: |\n          cd dist\n          zip -r ../rottentomatoes-reel-score-${{ github.event.release.tag_name }}.zip *\n      \n      - name: Upload release asset\n        uses: actions/upload-release-asset@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          upload_url: ${{ github.event.release.upload_url }}\n          asset_path: ./rottentomatoes-reel-score-${{ github.event.release.tag_name }}.zip\n          asset_name: rottentomatoes-reel-score-${{ github.event.release.tag_name }}.zip\n          asset_content_type: application/zip\n```\n\n2. Add build and lint scripts to package.json:\n```json\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"lint\": \"eslint src/**/*.js\",\n    \"lint:fix\": \"eslint src/**/*.js --fix\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\"\n  }\n}\n```\n\n3. Create ESLint configuration:\n```javascript\n// .eslintrc.js\nmodule.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n    webextensions: true,\n    jest: true\n  },\n  extends: [\n    'eslint:recommended'\n  ],\n  parserOptions: {\n    ecmaVersion: 12,\n    sourceType: 'module'\n  },\n  rules: {\n    'indent': ['error', 2],\n    'linebreak-style': ['error', 'unix'],\n    'quotes': ['error', 'single'],\n    'semi': ['error', 'always'],\n    'no-unused-vars': ['warn'],\n    'no-console': ['warn', { allow: ['warn', 'error'] }]\n  }\n};\n```\n\n4. Create Vite configuration:\n```javascript\n// vite.config.js\nimport { defineConfig } from 'vite';\nimport { resolve } from 'path';\n\nexport default defineConfig({\n  build: {\n    outDir: 'dist',\n    rollupOptions: {\n      input: {\n        content: resolve(__dirname, 'src/content.js'),\n        options: resolve(__dirname, 'options.html'),\n        popup: resolve(__dirname, 'popup.html')\n      },\n      output: {\n        entryFileNames: '[name].js',\n        chunkFileNames: '[name].js',\n        assetFileNames: '[name].[ext]'\n      }\n    }\n  },\n  resolve: {\n    alias: {\n      '@': resolve(__dirname, 'src')\n    }\n  }\n});\n```",
        "testStrategy": "Test the GitHub Actions workflow by creating a test PR. Verify that linting, testing, and building steps complete successfully. Test the release process by creating a test release tag.",
        "priority": "low",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-03T20:04:26.103Z",
      "updated": "2025-07-03T20:05:21.134Z",
      "description": "Tasks for master context"
    }
  }
}